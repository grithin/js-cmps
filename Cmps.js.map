{"version":3,"sources":["Cmps/Cmps.coffee"],"names":["window","Cmps","all","dependencies","loaded","cache","log","console","bind","singleton","name","options","_","isString","Error","this","state","trigger","Date","add_loaded","instance","push","require","dependent","dependents","update","remove_loaded","o","ref","results","isArray","filter","gc","length","destroy","dgc","debounce","page","scoped","current","args","apply","arguments","Cmp","Backbone","Model","extend","data","createData","$els","events","prototype","construct","attachEvents","event","i","len","type","$","target","get","addEventListener","fn","selecter","on","detachEvents","removeEventListener","off","Collection","partial","$element","$el","remove","createClass","constructor","wrapped_constructor","applied","call","inherited","context","c","el_wrap","html","$wrap","classable_name","replace","addClass","append","el_attached_wrap"],"mappings":"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","file":"Cmps/Cmps.js","sourcesContent":["###\n\nMethodologies:\n-\tA component can have singleton dependencies, which tend to be wrappers\n-\tWhen a component is destroyed, a debounce is used so that, if another component is created requiring some of the same dependecies, the dependencies are not needlessly destroyed\n\n@TODO\tcmp.destroy allowed to return promise, in which case, will wait for it\n@TODO\tno-debug version (clear `c` calls)\n@TODO\twrite examples\n###\n\nwindow.Cmps =\n\tall: {} # dictionary of all component types, by name of component\n\tdependencies: {} # { name: < instance >, ... }\n\tloaded: {} # { name: < instance >, name: [< instance >, ...] }\n\tcache: {} # conveniences obj for Cmps to place re-usable instances of theselves\n\tlog: console.log.bind(console)\n\t#\tname: instance # for single instance Cmps that have significant construct costs, and perfer to partially-destroy, and reuse data on re-construction\n\n\n# create Cmp if instance does not exist\nCmps.singleton = (name, options)->\n\tif !_.isString name\n\t\tthrow new Error('Component name must be a string')\n\tif !@loaded[name]\n\t\t@loaded[name] = new @all[name](name, options)\n\t\t@loaded[name].state.trigger 'loaded', (new Date) # tell the component it was loaded\n\t@loaded[name]\n# Type 1: not-dependency\nCmps.add_loaded = (instance)->\n\tif @loaded[instance.name]\n\t\t@loaded[instance.name].push instance\n\telse\n\t\t@loaded[instance.name] = [instance]\n# Type 2: dependency\nCmps.require = (name, dependent, options)->\n\tif !@all[name]\n\t\tthrow new Error('Unknown component dependency: \"'+name+'\"')\n\n\tif @dependencies[name]\n\t\tCmps.log 'Cmps: dependency preloaded: '+name\n\t\t@dependencies[name].dependents.push dependent\n\t\t# @TODO remake this to use .state.on('change:reloaded')\n\t\t@dependencies[name].update('require', options) # tell the component it was re-required\n\telse\n\t\tCmps.log 'Cmps: dependency loading: '+name\n\t\t@dependencies[name] = new @all[name](name, options)\n\t\t@dependencies[name].dependents = [dependent]\n\t\t@dependencies[name].state.trigger 'loaded', (new Date) # tell the component it was loaded\n\t@dependencies[name]\n# remove self from loaded, and from dependents\nCmps.remove_loaded = (instance)->\n\tif _.isArray @loaded[instance.name]\n\t\t@loaded[instance.name] = @loaded[instance.name].filter (o)->\n\t\t\to != instance\n\telse\n\t\tdelete @loaded[instance.name]\n\tfor name, o of @dependencies\n\t\tif o.dependents\n\t\t\to.dependents = o.dependents.filter (o)->\n\t\t\t\to != instance\n# remove Cmps with empty dependents list\nCmps.gc = ()->\n\tfor name, o of @dependencies\n\t\tif o.dependents && !o.dependents.length\n\t\t\tdelete @dependencies[name]\n\t\t\to.destroy()\n# debounced garbage collecter\nCmps.dgc = _.debounce Cmps.gc.bind(Cmps), 100\n\n# a primary singleton component serving as a page (the current page will be swapped out with the new page)\nCmps.page = scoped {current:false}, (name, args)->\n\tif @current\n\t\t@current.destroy()\n\t@current = Cmps.singleton.apply Cmps, arguments\n\n\n###\nStandard Attributes\n-\tname: the name of the component\n-\tstate: if a component is stateful and that statefulness is potentially used by something external, store the state here\n-\tdata: location to put the data, normally as a backbone collection or model\n-\tevents: array of events that should be attached when the component is created and detached when destroyed\n\t-\tsee code for details\n-\t$el: a single jquery element representing the component, which will be destroyed when the components is destroyed\n-\t$els: an array of jquery elements representing the component, which will be destroyed when the components is destroyed\n\t-\tfor named els:\n\t```\n\t@els = $nav: $('...')\n\t@$els.push @els.$nav\n\t```\n\nEvents\n-\tWhen loaded, `state` gets a \"loaded\" event, with the time\n-\tWhen destroyed, `state` gets a 'destroyed' event, with the time\n-\tWhen re-required as singleton, `update` method is called on the component with parameter `'require'`\n-\tWhen the component is updated, it should emit a 'update' event on the `@state`\n###\n\nwindow.Cmp = (name)->\n\tif !_.isString name\n\t\tthrow new Error('Component name must be a string')\n\t@name = name\n\tif !@state\n\t\t@state = new (Backbone.Model.extend())\n\n\tif !@data\n\t\t@createData()\n\n\tif !@$els # component may have multiple elements\n\t\t@$els = []\n\n\tif !@events\n\t\t@events = []\n\t###\n\t@events = [\n\t\t{ name: 'click', target: $(), fn: (()->)\t} # basic bubble event\n\t\t{ name: 'click', target: $(), selecter: '', fn: (()->)\t} # delegation with selecter\n\t\t{ name: 'click', target: $(), fn: (()->), type:'capture'\t} # capture event\n\t]\n\t###\nCmp::require = (name, options)->\n\tCmps.require(name, @, options)\n# Add/attach events\nCmp::construct = ()->\n\tif @events.length\n\t\t@attachEvents()\n\tCmps.add_loaded(@)\nCmp::attachEvents = (events)->\n\tevents = events || @events\n\tfor event in events\n\t\tif event.type == 'capture'\n\t\t\t$(event.target).get(0).addEventListener(event.name, event.fn, true) # last argument indicates to capture\n\t\telse if event.selecter\n\t\t\t$(event.target).on(event.name, event.selecter, event.fn)\n\t\telse\n\t\t\t$(event.target).on(event.name, event.fn)\nCmp::detachEvents = (events)->\n\tevents = events || @events\n\tfor event in events\n\t\tif event.type == 'capture'\n\t\t\t$(event.target).get(0).removeEventListener(event.name, event.fn, true) # last argument indicates to capture\n\t\telse if event.selecter\n\t\t\t$(event.target).off(event.name, event.selecter, event.fn)\n\t\telse\n\t\t\t$(event.target).off(event.name, event.fn)\n# Like with react, the notion is, when the data changes, there is a render update.   Consequently, the Cmp @data is a backbone model, which, when updated, calls the cmp update method\nCmp::createData = (data={})->\n\tif _.isArray(data)\n\t\t@data = new (Backbone.Collection.extend())(data)\n\telse\n\t\t@data = new (Backbone.Model.extend())(data)\n\t@data.on 'remove change add', _.partial @update.bind(@), 'data' # call `update` with a '\"data\"' parameter when changed\n###\n-\tremove the primary element\n-\tremove events\n###\nCmp::destroy = ()->\n\tCmps.log 'Cmp: destroying: '+@name\n\tif @$el\n\t\t@$el.remove()\n\tfor $element in @$els\n\t\t$element.remove()\n\tif @events\n\t\t@detachEvents()\n\tCmps.remove_loaded(@)\n\tCmps.dgc()\n\t@state.trigger('destroyed', new Date)\nCmp::createClass = (name, constructor)->\n\t# wrap to run final @construct()\n\twrapped_constructor = ()->\n\t\tCmps.log 'Cmp: constructing: '+name\n\t\tapplied = constructor.call(@, arguments[1]) # the 2nd param is the options param.\n\t\t@construct()\n\t\tapplied\n\n\tCmps.all[name] = inherited Cmp, wrapped_constructor\n\tCmps.all[name]::name = name\n\tCmps.all[name]\n# @param\tcontext\t< the context for which update is called.  \"data\", for data change, \"require\", for when Cmp is required. >\nCmp::update = ((context)-> c 'Cmp: updating: '+ @name)\nCmp::el_wrap = (html)->\n\t$wrap = $('<div class=\"cmp_content\">')\n\tclassable_name = @name.replace(/[^a-z0-9_]/gi,'_')\n\t$wrap.addClass(classable_name)\n\t$wrap.append(html)\n\n#++ site specific {\n\nCmp::el_attached_wrap = (html)->\n\t@$el = @el_wrap(html)\n\t$('#pc').append @$el\n\t@$el\n\n#++ }"],"sourceRoot":"/source/"}